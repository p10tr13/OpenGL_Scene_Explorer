#version 400 core
#define NR_POINT_LIGHTS 1
#define NR_FLASHLIGHTS 1

layout(quads, fractional_even_spacing) in;

out vec3 Normal;
out vec3 FragPos;
out vec3 LightPos[NR_POINT_LIGHTS];
out vec3 FlashlightPos[NR_FLASHLIGHTS];
out vec3 FlashlightDir[NR_FLASHLIGHTS];
out vec3 DirLightDirection;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

uniform vec3 controlPoints[16];

uniform vec3 lightPos[NR_POINT_LIGHTS];
uniform vec3 dirLightDirection;
uniform vec3 flashlightPos[NR_FLASHLIGHTS];
uniform vec3 flashlightDir[NR_FLASHLIGHTS];

int BinomialCoefficient(int n, int k);
float BernsteinPolynomial(int n, int k, float t);


void main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec3 position = vec3(0.0);
    vec3 tangentU = vec3(0.0);
    vec3 tangentV = vec3(0.0);
    int n = 3;
    int m = 3;

    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            float Bi = BernsteinPolynomial(n, i, u);
            float Bj = BernsteinPolynomial(m, j, v);

            position += controlPoints[j + 4 * i] * Bi * Bj;

            if (i != n)
            {
                float Bim1 = BernsteinPolynomial(n - 1, i, u);
                tangentU += (controlPoints[(i + 1) * 4 + j] - controlPoints[j + 4 * i]) * Bim1 * Bj;
            }

            if (j != m)
            {
                float Bjm1 = BernsteinPolynomial(m - 1, j, v);
                tangentV += (controlPoints[i * 4 + j + 1] - controlPoints[j + 4 * i]) * Bjm1 * Bi;
            }
        }
    }

    tangentU *= n;
    tangentV *= m;

    FragPos = vec3(view * model * vec4(position,1.0));
    Normal = mat3(transpose(inverse(view * model))) * normalize(cross(tangentU, tangentV));

    for(int i = 0; i < NR_POINT_LIGHTS; i++)
		LightPos[i] = vec3(view * vec4(lightPos[i], 1.0));
	for(int i = 0; i < NR_FLASHLIGHTS; i++)
		FlashlightPos[i] = vec3(view * vec4(flashlightPos[i], 1.0));
	for(int i = 0; i < NR_FLASHLIGHTS; i++)
		FlashlightDir[i] = normalize(mat3(view) * flashlightDir[i]);
	DirLightDirection = mat3(view) * dirLightDirection;

    gl_Position = projection * view * model * vec4(position, 1.0);
};

int BinomialCoefficient(int n, int k)
{
    int r = 1;
    int d;
    if (k > n) return 0;

    for (d = 1; d <= k; d++)
    {
        r *= n--;
        r /= d;
    }
    return r;
};

float BernsteinPolynomial(int n, int k, float t)
{
    return BinomialCoefficient(n, k) * pow(t, k) * pow(1 - t, n - k);
};